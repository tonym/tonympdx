<!DOCTYPE html>
<html lang="en">
  <head>
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"
    />
    <title>Tony M | Portfolio</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Libre+Baskerville&display=swap"
      rel="stylesheet"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600&display=swap"
      rel="stylesheet"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Dancing+Script&display=swap"
      rel="stylesheet"
    />
    <link rel="icon" href="/assets/images/favicon.png" />
    <link
      rel="alternate"
      type="application/atom+xml"
      title="Tony M blog feed"
      href="/blog/feed.xml"
    />
    <link href="/assets/main.css?0999a2e287feea71155f" rel="stylesheet"><script src="/assets/0999a2e287feea71155f.js?0999a2e287feea71155f" defer="defer"></script>
    <script src="/assets/scripts/prism.js"></script>
  </head>
  <body class="line-numbers">
    <svg id="fader"></svg>
    <div class="nav-container">
  <nav class="navigation">
    <div class="brand">
      <a href="/" class="main-nav">
        <span class="fa fa-home"></span>
      </a>
    </div>
    <div class="links">
      <a href="/about" class="main-nav">About me</a>
<a href="/projects" class="main-nav">My work</a>
<a href="/work-with-me" class="main-nav">Services</a>
<a href="/blog/posts/1" class="main-nav">Blog</a>

    </div>
    <div class="links-menu">
      <label for="menu-control" class="menu-control"></label>
    </div>
  </nav>
</div>
<input type="checkbox" class="menu-control-checkbox" id="menu-control"/>
<div class="links-panel show-out" id="links-panel">
  <a href="/about" class="main-nav">About me</a>
<a href="/projects" class="main-nav">My work</a>
<a href="/work-with-me" class="main-nav">Services</a>
<a href="/blog/posts/1" class="main-nav">Blog</a>

</div>

    <div class="content">
      <h1 class="text-center">Building a design system 1 - setup</h1>
<div class="project-detail">
  <p>
    <img class="banner main-image" src="https://cdn.sanity.io/images/5pnyimif/production/eff93081fbcc3725a1b9afc554bdeb1ccb6d2cea-800x400.png" alt="Building a design system 1 - setup image">
  </p>
  <div class="dateline">
    <img src="https://cdn.sanity.io/images/5pnyimif/production/f9e5c3fc87fa0a3d927f162da02bc95ea8a26cf6-640x640.jpg" alt="author Tony M avatar">
    <div>
      <p class="author">Tony M</p>
      <p class="date body2">
        <time class="postlist-date" datetime="2022-08-27T19:20:11.956Z">
          27 Aug 2022
        </time>
        -
        12 min read
      </p>
    </div>
  </div>
  <p>Let's begin. If you like, you can review the <a href="/blog/post/building-a-design-system-introduction/">introduction</a> before we proceed.</p>
<p>In this walkthrough, we'll set up a repository and start adding to it. Our design system repo covers all the groundwork, and we'll add the first code.</p>
<p>The code for this post is available at:</p>
<ul>
<li><a href="https://github.com/tonym/whirlwind/tree/lesson-1">https://github.com/tonym/whirlwind/tree/lesson-1</a></li>
</ul>
<h2>Goals</h2>
<ul>
<li>Install dependencies</li>
<li>Add some Typescript types</li>
<li>Set up state management</li>
<li>Configure testing</li>
<li>Add a function to create a stylesheet</li>
</ul>
<h2>Skills</h2>
<p>You should know how to set up a Git repo, have a basic understanding of Typescript, and be familiar with Jest and Redux.</p>
<h2>Difficulty level</h2>
<p>Advanced. This is an advanced tutorial and assumes that you are a moderately experienced frontend developer. Beginning developers may find this challenging.</p>
<h2>Overview</h2>
<p>This is the first step on our way to building the engineering side of a design system. The design side will be discussed later, but for now, we're going to set up the things we need to create themes, then add tokens.</p>
<p>The ultimate goal of our system is the consistent application of UX via components which, as we will see, do not always have to be part of the design system, and the consistent application of style via a theming engine, which is where we're starting in this exercise.</p>
<p>For the designer, this means consistent appearance and functionality, and for the developer, this means style and UX come ready-made, and when the designer changes the design, there is no refactoring. We are creating an automated application of style and user experience.</p>
<h2>Repositories</h2>
<p>This project requires three repositories, one for the design system because it will be distributed via NPM, another for a monorepo with our test applications, and a third optional repo for Angular. If you'd like to test with Angular, having it in its own repo may not be necessary, considering how you build your monorepo. Our monorepo will use Lerna and possibly Astro, which doesn't work with Angular, so I isolate NG on an island of its own.</p>
<p>For now, only the design system repo is needed. We won't go into how to create a repo here, but if you are following along, create a new repo, and let's start adding some dependencies.</p>
<h2>Dependencies</h2>
<p>Over the course of this project, we'll add dependencies as we need them. For this exercise, install the following:</p>
<h3>JSS</h3>
<p>The JSS package transpiles JSS to CSS and injects a stylesheet into the head of an HTML document. We'll also install the default preset.</p>
<p>JSS documentation: <a href="https://cssinjs.org">https://cssinjs.org</a></p>
<p>Install using NPM or Yarn:</p>
<pre><code class="language-sh">npm install jss jss-preset-default
</code></pre>
<p>or</p>
<pre><code class="language-sh">yarn add jss jss-preset-default
</code></pre>
<h3>Redux</h3>
<p>Redux is for state management. While JSS comes with a stylesheet manager, we have more things than stylesheets in our store. Eventually, the store will have stylesheets, themes, and tokens, but we'll deal with themes and tokens later. For now, we'll build the store with placeholders.</p>
<p>Redux documentation: <a href="https://redux.js.org/">https://redux.js.org/</a></p>
<p>Install using NPM or Yarn:</p>
<pre><code class="language-sh">npm install redux
</code></pre>
<p>or</p>
<pre><code class="language-sh">yarn add redux
</code></pre>
<h3>Typescript</h3>
<p>Install using NPM or Yarn:</p>
<pre><code class="language-sh">npm install --save-dev typescript
</code></pre>
<p>or</p>
<pre><code class="language-sh">yarn add --dev typescript
</code></pre>
<h3>Jest</h3>
<p>For our tests, install jest version 28</p>
<p>Install using NPM or Yarn:</p>
<pre><code class="language-sh">npm install --save-dev jest@^28.1.8
</code></pre>
<p>or</p>
<pre><code class="language-sh">yarn add --dev jest@^28.1.8
</code></pre>
<p>For this project, we're using the <strong>jsdom</strong> test environment which is no longer included in the core Jest package.</p>
<p>Install using NPM or Yarn:</p>
<pre><code class="language-sh">npm install --save-dev jest-environment-jsdom
</code></pre>
<p>or</p>
<pre><code class="language-sh">yarn add --dev jest-environment-jsdom
</code></pre>
<p>Now add the Jest preset for Typescript.</p>
<p>Install using NPM or Yarn:</p>
<pre><code class="language-sh">npm install --save-dev ts-jest
</code></pre>
<p>or</p>
<pre><code class="language-sh">yarn add --dev ts-jest
</code></pre>
<p>Since we're using Typescript, we need some types. Types are included in Jest core; however, if we want to use those, they must be imported into every test. If you don't want to do that, add the types from Definitely Typed.</p>
<p>Install using NPM or Yarn:</p>
<pre><code class="language-sh">npm install --save-dev @types/jest
</code></pre>
<p>or</p>
<pre><code class="language-sh">yarn add --dev @types/jest
</code></pre>
<p>Optionally, if you like JUnit output for your tests, install the Jest JUnit plugin.</p>
<p>Install using NPM or Yarn:</p>
<pre><code class="language-sh">npm install --save-dev jest-junit
</code></pre>
<p>or</p>
<pre><code class="language-sh">yarn add --dev jest-junit
</code></pre>
<h3>CSSType</h3>
<p>JSS provides JSS types, but we also need CSS types.</p>
<p>Install using NPM or Yarn:</p>
<pre><code class="language-sh">npm install --save-dev csstype
</code></pre>
<p>or</p>
<pre><code class="language-sh">yarn add --dev csstype
</code></pre>
<h2>Configure Typescript</h2>
<p>Add these three files to the project root.</p>
<p>tsconfig.json</p>
<pre><code class="language-json">{
  &quot;compilerOptions&quot;: {
    &quot;baseUrl&quot;: &quot;.&quot;,
    &quot;target&quot;: &quot;es5&quot;,
    &quot;module&quot;: &quot;esnext&quot;,
    &quot;lib&quot;: [&quot;esnext&quot;, &quot;dom&quot;],
    &quot;declaration&quot;: true,
    &quot;sourceMap&quot;: false,
    &quot;outDir&quot;: &quot;./dist&quot;,
    &quot;rootDir&quot;: &quot;./src&quot;,
    &quot;strict&quot;: true,
    &quot;noImplicitAny&quot;: false,
    &quot;strictNullChecks&quot;: true,
    &quot;strictFunctionTypes&quot;: true,
    &quot;strictBindCallApply&quot;: true,
    &quot;strictPropertyInitialization&quot;: false,
    &quot;noImplicitThis&quot;: true,
    &quot;noUnusedLocals&quot;: false,
    &quot;noUnusedParameters&quot;: false,
    &quot;noImplicitReturns&quot;: true,
    &quot;noFallthroughCasesInSwitch&quot;: true,
    &quot;moduleResolution&quot;: &quot;node&quot;,
    &quot;experimentalDecorators&quot;: true,
    &quot;resolveJsonModule&quot;: true,
    &quot;skipLibCheck&quot;: true
  },
  &quot;exclude&quot;: [&quot;**/dist&quot;, &quot;**/*.test*&quot;, &quot;**/testing&quot;]
}
</code></pre>
<p>tsconfig.dev.json</p>
<pre><code class="language-json">{
  &quot;extends&quot;: &quot;./tsconfig.json&quot;,
  &quot;include&quot;: [&quot;./src/**/*&quot;]
}
</code></pre>
<p>tsconfig.test.json</p>
<pre><code class="language-json">{
  &quot;extends&quot;: &quot;./tsconfig.json&quot;,
  &quot;compilerOptions&quot;: {
    &quot;allowJs&quot;: true,
    &quot;outDir&quot;: &quot;./out-tsc/spec&quot;,
    &quot;esModuleInterop&quot;: true,
    &quot;emitDecoratorMetadata&quot;: true,
    &quot;sourceMap&quot;: true,
    &quot;types&quot;: [&quot;jest&quot;, &quot;node&quot;]
  },
  &quot;files&quot;: [&quot;./src/test.ts&quot;],
  &quot;include&quot;: [&quot;./src/**/*.test.ts&quot;, &quot;./src/**/*.d.ts&quot;]
}
</code></pre>
<h2>Configure Jest</h2>
<p>Add jest.config.js to the project root.</p>
<pre><code class="language-javascript">module.exports = {
  coveragePathIgnorePatterns: ['/node_modules/', 'index.ts'],
  globals: {
    'ts-jest': {
      tsconfig: 'tsconfig.test.json'
    }
  },
  moduleFileExtensions: ['ts', 'js'],
  preset: 'ts-jest',
  testEnvironment: 'jsdom',
  testMatch: ['**/?(*.)+(test).ts?(x)'],
  transform: { '^.+\\.(js|jsx|ts|tsx)$': 'ts-jest' },
  reporters: ['default', 'jest-junit']
};
</code></pre>
<p>We need a way to run our tests, so add these NPM scripts to your pacakge.json <strong>scripts</strong> section:</p>
<pre><code class="language-json"> &quot;test&quot;: &quot;jest --maxWorkers=50%&quot;,
 &quot;test:dev&quot;: &quot;jest --clearCache &amp;&amp; jest --coverage --no-cache --maxWorkers=50%&quot;
</code></pre>
<p>The <strong>test:dev</strong> script will show test coverage in the terminal when you run it. The <strong>maxWorkers</strong> argument is a recommended performance setting.</p>
<h2>File structure</h2>
<p>At this point, your repo file structure should look like this:</p>
<pre><code class="language-sh">| node_modules
| .gitignore
| jest.config.js
| LICENSE // if you created one
| package-lock.json
| package.json
| README.md
| tsconfig.dev.json
| tsconfig.json
| tsconfig.test.json
</code></pre>
<p>Now create a src folder and add a store folder for our Redux store, a styles folder for our theming engine functions, and a types folder for our typescript types.</p>
<pre><code class="language-sh">| node_modules
| src
|- store
|- styles
|- types
| .gitignore
| jest.config.js
| LICENSE
| package-lock.json
| package.json
| README.md
| tsconfig.dev.json
| tsconfig.json
| tsconfig.test.json
</code></pre>
<h2>Add types</h2>
<p>These are the types we'll need for this exercise. Create a types.ts file in the types folder. There is some preparation for later, and some placeholder, and we'll step through it line by line, but this is what the file should look like:</p>
<pre><code class="language-typescript">import { StyleSheet as StyleSheetJSS } from 'jss';

export interface Theme {}

export const ADD_SHEET = 'ADD_SHEET';

export type StyleSheet = StyleSheetJSS;

export type Sheet&lt;K extends keyof any, StyleSheet&gt; = { [P in K]: StyleSheet };

interface AddSheetAction {
  type: typeof ADD_SHEET;
  sheet: Sheet&lt;string, StyleSheet&gt;;
}

export type ActionTypes = AddSheetAction;

export interface State {
  sheets: Sheet&lt;string, StyleSheet&gt;;
  theme: Theme;
}

</code></pre>
<p>First, import the StyleSheet type from JSS and import it as StyleSheetJSS. Assign it to a <strong>StyleSheet</strong> type. We do this in case we have to extend the type later, and, more importantly, so we can import it from our types instead of the JSS node module.</p>
<p>The <strong>Theme</strong> interface is a placeholder. We'll get to themes in a later walkthrough, but for now, an empty object will let us get started.</p>
<p>Everything else is for our store. We have one action type, <strong>ADD_SHEET</strong>, and the action, <strong>AddSheetAction</strong>. They are exported as <strong>ActionTypes</strong>. Although not obvious here, <strong>ActionTypes</strong> is a union type, and as we add actions, we'll add them to the <strong>ActionTypes</strong> type.</p>
<p>The <strong>State</strong> interface is our store. Again, the <strong>theme</strong> type is just a placeholder for now.</p>
<p>Finally, add an index to the folder.</p>
<pre><code class="language-typescript">// file: /src/types/index.ts

export * from './types';
</code></pre>
<h2>Configure the store</h2>
<p>Our host application may need many stylesheets. No, that's wrong. A host application WILL need many stylesheets, and we don't want to duplicate them. Only one stylesheet for any given component should be in the markup. To manage the sheets and prevent duplicates, we'll use Redux.</p>
<h3>Actions</h3>
<p>At this point, we need one action, an action to add sheets to the store.</p>
<pre><code class="language-typescript">// file: /src/store/actions.ts

import { ActionTypes, ADD_SHEET, Sheet, StyleSheet } from '../types/index';

export function addSheet(sheet: Sheet&lt;string, StyleSheet&gt;): ActionTypes {
  return { type: ADD_SHEET, sheet };
}
</code></pre>
<p>Do you notice how the types are imported explicitly from the index file? This is because all imports from our codebase should come from a single barrel. The index files that export from the files in a folder is the barrel, and while we could import from the files themselves, it's preferable to import from the barrel, which is also our public API. Our bundle will then have a single entry point, which is helpful for the requirements of certain host applications, some bundling schemes, and Angular's AOT compiler if you have to support that.</p>
<h3>Reducer</h3>
<p>The reducer updates the store and holds the initial state.</p>
<pre><code class="language-typescript">// file: /src/store/reducer.ts

import { ActionTypes, ADD_SHEET, State } from '../types/index';

export const initialState: State = {
  sheets: {},
  theme: {}
};

export function reducer(
  state: State = initialState,
  action: ActionTypes
): State {
  switch (action.type) {
    case ADD_SHEET:
      const sheets = { ...state.sheets, ...action.sheet };
      return { ...state, sheets: sheets };
    default:
      return state;
  }
}
</code></pre>
<p>Again, we import types from the barrel, then declare the <strong>initialState</strong>. State will hold many <strong>sheets</strong> and one <strong>theme</strong>. <strong>Sheets</strong> are the stylesheets we'll soon create, and they get dispatched to the store with a key, and the sheet. When JSS creates a stylesheet, we can provide it with some options, including a <strong>meta</strong> property which is a unique identifier string. That string is what we will use as our sheet key in the state <strong>sheets</strong> object. We can check for the existence of that key and reuse the sheet instead of creating a new one. Further, we will be able to know that if the sheet is in the store, it is in the markup, and we don't have to attach it again. So if we have ten buttons on our host page, only one button stylesheet will be in the page HEAD.</p>
<h3>Initialize</h3>
<p>Now we need a way to initialize the store and make it available to the theming engine.</p>
<pre><code class="language-typescript">// file: /src/store/store.ts

import { createStore, Store } from 'redux';
import { reducer } from './reducer';

export const store: Store = createStore(reducer);
</code></pre>
<p>We pass the reducer to the store constructor. The reducer is imported from the reducer file because it is in the same folder as our working file. If we import from the barrel in the same folder as the file we're importing from, we'll have a circular dependency error in both Rollup and the optional Angular compiler when we create our NPM package.</p>
<h3>Export</h3>
<p>Export everything.</p>
<pre><code class="language-typescript">// file: /src/store/index.ts

export * from './store';
export * from './actions';
export * from './reducer';
</code></pre>
<h2>Defaults</h2>
<p>Next, we should set up some defaults. We'll create a file called defaulTheme, which gives us a default theme, which is an empty object for now (we'll construct the theme later), and our default JSS options. For the JSS options, the defaults from the node package are all we need, but if at some point you need more options, they can be done here.</p>
<pre><code class="language-typescript">// file: /src/styles/defaultTheme/defaultTheme.ts

import { JssOptions } from 'jss';
import preset from 'jss-preset-default';
import { initialState } from '../../store/reducer';
import { Theme } from '../../types/types';

const defaultJssPlugins = preset();

export const defaultJssOptions: JssOptions = {
  ...defaultJssPlugins
};

export const defaultTheme: Theme = initialState.theme;

export default defaultTheme;
</code></pre>
<p>Notice how the theme is derived from <strong>intialState</strong>. That's what makes it the default theme. In later exercises, we'll add the mechanism to construct a custom theme; however, the default, in many cases the default look of an application or the brand identity, is where design starts.</p>
<p>It's a good time to mention the export scheme. Our theming engine, everything in the styles folder, is a collection of functions, not all of which may be needed in a host application. Each of these functions is its own file, and each file has a default export.</p>
<p>Default exports enable path imports, and that enables tree-shaking. Our final bundle will include ES modules and CommonJS modules, plus accommodation for name imports and, optionally, a bundle for Angular Ivy, the AOT compiler used in newer versions of Angular.</p>
<p>The Angular part only matters if you have to support Ivy, but everything else, which we will examine when we add Rollup and configure bundling, is designed to support different bundling strategies and tree-shaking, as well as CJS require statements.</p>
<h2>The first creator</h2>
<p>The theming engine relies on two types of functions: <strong>creators</strong> and <strong>providers</strong>. Creators create a thing, and providers provide that thing to the host application. We'll see our first provider in the next exercise, but our first creator happens now.</p>
<p>This is a stylesheet creator. All it does is create a stylesheet. In the next exercise, we'll add a stylesheet provider which will take the created stylesheet, dispatch it to the store, and attach it to the HEAD of the host view. Before we can do that, however, we need a creator.</p>
<pre><code class="language-typescript">// file: /src/styles/createStylesheet/createStylesheet.ts

import jss, { Styles, StyleSheetFactoryOptions } from 'jss';
import { StyleSheet } from '../../types/index';
import { defaultJssOptions } from '../defaultTheme/index';

export default function createStylesheet(
  styles: Styles,
  options: StyleSheetFactoryOptions = {}
): StyleSheet {
  jss.setup(defaultJssOptions);
  return jss.createStyleSheet(styles, options);
}
</code></pre>
<p>The <strong>styles</strong> property is a JSS styles object or CSS written as JSON. The <strong>options</strong> property is JSS factory options for creating the stylesheet, which may include a <strong>meta</strong> property (the stylesheet identifier) and an <strong>index</strong>, which is the order of the stylesheets attached to the head. A sheet with an index of 1 will come before a sheet with an index of 3 in the host markup. The function then returns a JSS stylesheet object.</p>
<p>Now that we can create a stylesheet, it's a good place to end the coding of this exercise and write some tests. So far, all we've done is prepare. In the next part, we'll start using what we've created, but let's not get ahead of ourselves. We don't want to use anything untested.</p>
<h2>Testing the store</h2>
<p>Now that we've completed the code for this setup exercise, we'll write some tests beginning with the store.</p>
<h3>Actions</h3>
<p>Create a test file and add it to the store folder.</p>
<pre><code class="language-typescript">// file: /src/store/actions.test.ts

import { StyleSheetFactoryOptions } from 'jss';
import { addSheet } from './actions';
import { ADD_SHEET, StyleSheet } from '../types/index';
import createStylesheet from '../styles/createStylesheet/index';

const options: StyleSheetFactoryOptions = {
  meta: 'Styles'
};
const stylesheet: StyleSheet = createStylesheet({}, options);

describe('Actions', () =&gt; {
  it(`should create an ${ADD_SHEET} action`, () =&gt; {
    const key = options.meta || '';
    const sheet = { [key]: stylesheet };
    const action = addSheet(sheet);
    expect(action).toEqual({ type: ADD_SHEET, sheet });
  });
});
</code></pre>
<p>Our setup includes an <strong>options</strong> object. We've discussed JSS factory options, but here we actually see it in use.</p>
<pre><code class="language-typescript">const options: StyleSheetFactoryOptions = {
  meta: 'Styles'
};
</code></pre>
<p>These options are passed to the stylesheet creator. We don't need any styles, just a stylesheet to test our action creator so our styles can be an empty object.</p>
<pre><code class="language-typescript">const stylesheet: StyleSheet = createStylesheet({}, options);
</code></pre>
<p>There is only one test because there is only one action creator, so we test that it returns a proper action. When we assign a value to the <strong>key</strong> constant, Typescript knows that it could be undefined or null, so we account for it conditionally.</p>
<pre><code class="language-typescript">const key = options.meta || '';
</code></pre>
<p>Then create the sheet, call the action creator, and expect it to be correct.</p>
<pre><code class="language-typescript">const sheet = { [key]: stylesheet };
const action = addSheet(sheet);
expect(action).toEqual({ type: ADD_SHEET, sheet });
</code></pre>
<h3>Reducer</h3>
<p>Create a reducer test file and add it to the store folder.</p>
<pre><code class="language-typescript">// file: /src/store/reducer.test.ts

import { StyleSheet, StyleSheetFactoryOptions } from 'jss';
import { reducer, initialState } from './reducer';
import { ActionTypes, ADD_SHEET } from '../types/index';
import createStylesheet from '../styles/createStylesheet/index';

describe('Reducer', () =&gt; {
  it(`should add a sheet to state from an ${ADD_SHEET} action`, () =&gt; {
    const options: StyleSheetFactoryOptions = {
      meta: 'Styles'
    };
    const stylesheet: StyleSheet = createStylesheet({}, options);
    const key = options.meta || '';
    const sheet = { [key]: stylesheet };
    const action: ActionTypes = { type: ADD_SHEET, sheet };
    const newState = reducer(initialState, action);
    const sheetInStore = newState.sheets[key];
    expect(sheetInStore).toEqual(stylesheet);
  });
});
</code></pre>
<p>There is only one test because there is only one action, but the setup is the same, except we don't call the action creator.</p>
<pre><code class="language-typescript">const options: StyleSheetFactoryOptions = {
  meta: 'Styles'
};
const stylesheet: StyleSheet = createStylesheet({}, options);
const key = options.meta || '';
const sheet = { [key]: stylesheet };
const action: ActionTypes = { type: ADD_SHEET, sheet };
</code></pre>
<p>Now we can call the reducer with the <strong>addSheet</strong> action and expect to see the sheet in the store.</p>
<pre><code class="language-typescript">const newState = reducer(initialState, action);
const sheetInStore = newState.sheets[key];
expect(sheetInStore).toEqual(stylesheet);
</code></pre>
<h3>Store</h3>
<p>The only thing the store file does is initialize the store, so we only need to check that it does what it claims.</p>
<pre><code class="language-typescript">// file: /src/store/store.test.ts

import { store } from './store';

describe('Store', () =&gt; {
  it('should create', () =&gt; {
    expect(store).toBeTruthy();
  });
});
</code></pre>
<h2>Testing the theming engine</h2>
<p>So far, the theming engine only has two things in it, a <strong>defaultTheme</strong> and a stylesheet creator. Let's finish this step with two more test files.</p>
<h3>defaultTheme</h3>
<p>Add a default theme test to the defaultTheme folder.</p>
<pre><code class="language-typescript">// file: /src/styles/defaultTheme/defaultTheme.test.ts

import { defaultJssOptions, defaultTheme } from './defaultTheme';

describe('defaultTheme', () =&gt; {
  it('should return default JSS options', () =&gt; {
    expect(defaultJssOptions).toBeTruthy();
  });

  it('should return a default theme', () =&gt; {
    expect(defaultTheme).toBeTruthy();
  });
});
</code></pre>
<p>The default theme exports two constants. Our tests should check that they exist.</p>
<h3>Stylesheet creator</h3>
<p>Add a test for the stylesheet creator.</p>
<pre><code class="language-typescript">// file: /src/styles/createStylesheet/createStylesheet.test.ts

import createStylesheet from './createStylesheet';

const styles = {
  body: {
    margin: 'auto'
  }
};

const stylesheet = createStylesheet(styles);

const styleRule = stylesheet.getRule('body');

describe('createStylesheet', () =&gt; {
  it('should create', () =&gt; {
    expect(stylesheet).toBeTruthy();
  });

  it('should create valid CSS from JSS', () =&gt; {
    expect(styleRule.toString()).toMatch('margin: auto;');
  });
});
</code></pre>
<p>This test checks that we have a valid JSS stylesheet object as the return value. We don't have to test the JSS stylesheet object itself because it is tested by the tests in the JSS NPM package. Assuming we can trust them (if you don't, you can run them and check the coverage), it is enough for us to check that a rule we add is in the object.</p>
<p>The setup is creating a styles object, then creating a stylesheet, then selecting our rule from the created stylesheet. The <strong>getRule</strong> function is a method of the JSS stylesheet object.</p>
<pre><code class="language-typescript">const styles = {
  body: {
    margin: 'auto'
  }
};

const stylesheet = createStylesheet(styles);

const styleRule = stylesheet.getRule('body');
</code></pre>
<p>We then test that the stylesheet has been created.</p>
<pre><code class="language-typescript">it('should create', () =&gt; {
  expect(stylesheet).toBeTruthy();
});
</code></pre>
<p>Then we test that it is what we expect. Remember, we put JSS in, and we get CSS out, so our <strong>body</strong> rule should be CSS in the stylesheet object.</p>
<pre><code class="language-typescript">it('should create valid CSS from JSS', () =&gt; {
  expect(styleRule.toString()).toMatch('margin: auto;');
});
</code></pre>
<h2>Create a public API</h2>
<p>So far, as we've written our code, we've exported from the files and folders we've created. Let's create our public API by adding index files to containing folders and the root. This is already done for the store because there are no subfolders, but we haven't done so for the styles folder.</p>
<p>Add contents of the styles folder to the index.</p>
<pre><code class="language-typescript">// file: /src/styles/index.ts

export { default as createStylesheet } from './createStylesheet/index';
export * from './createStylesheet/index';

export { default as defaultTheme } from './defaultTheme/index';
export * from './defaultTheme/index';
</code></pre>
<p>Next, create a file called public-api.ts and add it to src.</p>
<pre><code class="language-typescript">// file: /src/public-api.ts

export * from './store/index';
export * from './styles/index';
export * from './types/index';
</code></pre>
<p>Lastly, an index that exports from public-api. The public-api file is for Angular. Angular default is an export from a public-api.ts file, but if you are not supporting Angular, there is no need for public-api.ts, and you can use whatever filename you like. Typically it would be index, which is what we add next.</p>
<pre><code class="language-typescript">// file: /src/index.ts

export * from './public-api';
</code></pre>
<h2>Finish</h2>
<p>At this point, we can run the tests. We'll use <strong>test:dev</strong> to see the coverage report.</p>
<pre><code class="language-sh">npm run test:dev
</code></pre>
<p>If we did it right, our code is covered. You should see something like this in your terminal.</p>
<p><img src="https://cdn.sanity.io/images/5pnyimif/production/bdeb2ca7fcef23aab88007959e1a50af2a9f5d20-1678x838.png?w=600" alt="undefined"></p>
<p>That's it! Confusing as it may be at this point, things will clear up once we start using what we've done and adding more functionality. That will happen next time, even if all we've done so far is setup. Hopefully, the tests give some idea of what we intend and where we're going. Next time, we'll start using what we've built by adding a provider, attaching the stylesheet to the host markup, and dispatching it to the store.</p>
<p><a href="/blog/post/building-a-design-system-2-setup-continued/">Continue with part 2</a></p>

</div>


    </div>
    <footer>
  <div class="name-plate hidden-mobile">
    <h3 class="tag">Tony M</h3>
  </div>
  <div class="name-description">
    <p class="tag hidden-mobile">Portland, Oregon</p>
    <h3 class="contact-links tag">
      <a href="https://github.com/tonym" rel="noopener noreferrer" target="_blank">
        <span class="fab fa-github"></span>
      </a>
    </h3>
    <h3 class="contact-links tag">
      <a href="https://www.linkedin.com/in/tonympdx/" rel="noopener noreferrer" target="_blank">
        <span class="fab fa-linkedin"></span>
      </a>
    </h3>
    <h3 class="contact-links tag">
      <a href="mailto:tony@fbpllc.com" rel="noopener noreferrer" target="_blank">
        <span class="fas fa-envelope"></span>
      </a>
    </h3>
    <h3 class="tag hidden-mobile">Portfolio</h3>
  </div>
</footer>

  </body>
</html>
